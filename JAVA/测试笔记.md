# Eclips 常用快捷键



| 快捷键                | 快捷键说明                     |
| --------------------- | ------------------------------ |
| Alt + /               | 智能提示                       |
| Ctrl + 1              | 快速修复                       |
| ALt + Shift +N        | 新建                           |
| Ctrl + W              | 关闭当前窗口                   |
| Ctrl  + Shift +W      | 关闭所有窗口                   |
| Ctrl + S              | 保存                           |
| Ctrl + Shift + S      | 保存所有                       |
| Ctrl + F              | 在当前文件查找                 |
| Ctrl + H              | 在项目中查找                   |
| Ctrl + /              | 单行/取消注释                  |
| Ctrl + Shift + /      | 块注释                         |
| Ctrl + Shift + \      | 取消块注释                     |
| Ctrl + Shift + F      | 代码格式化（自动对齐）         |
| Ctrl +Shift + O       | 自动导入所有需要的类           |
| Shif + enter          | 再当前行下面产生空行           |
| Ctrl + Alt + 向下箭头 | 复制一行                       |
| Alt + 向下/上箭头     | 移动一行                       |
| Ctrl + D              | 删除一行                       |
| Alt + Shift + R       | 重命名                         |
| Alt + Shift + M       | 把一段代码抽象为一个方法       |
| Alt  + Shift + L      | 把一个表达式赋值给一个局部变量 |
| Ctrl + Shift + T      | 打开类型                       |
| Ctrl + O              | 显示成员                       |
| Ctrl + F11            | 运行程序                       |
| F11                   | 调试程序                       |
| Ctrl + Shift + B      | 添加/取消断点                  |
| Alt + Shift + S       | 调出默认重写选择器             |
| Alt + Shift + J       | 快速添加文档注释               |



# Final修饰符

1、final 修饰类，表示该类是最终类，不能被集成

System/String/Scanner就是final修饰的类

2、finla修饰字段，字段（Field），也叫成员变量，包括实例变量与静态变量

1）final修饰的字段必须显式的赋值，经常在定义final字段的同事就赋值，

2）final修饰的字段也可以在构造方法中给final 修复师的实例变量赋值

3)final 修饰的字段不能再重新被赋值

4)一般情况下，final 与static 都是同时使用的，覅按了字段所有字母都大写，成为final常量

3、final修饰方法，表示方法不能被子类重写

4、final 修饰局部变量，一旦初始化就不能再被修改，注意final修饰引用类型变量，是指这个引用类型变量不能再指向其他对象，但可以修改它的属性值

5、final 修饰方法的形参，在方法体中，不能修改fina形参的值



# 抽象类

1、对一组对象进行更高一级抽象时，形成抽象类，就可以定义为抽象类

2、普通类有的实例变量/实例方法/静态变量/构造方法等所有成员都可以在抽象类中定义

3、抽象类型也是一种应用数据类型

​		Java数据类型包括基本类型与应用，其中引用类型包括：类，接口，数组，枚举

4、抽象列不能实例化对象，抽象类的应用需要赋值子类对象

5、含有抽象方法的类必须定义为抽象类

6、子类继承了抽象类，子类需要重写抽象类中所有的抽象方法，如果子类没有重写抽象类的所有抽象方法，则子类也必须定义为抽象类

7、抽象类中不一定必须有抽象方法



# 接口

1、如何定义接口

​	【修饰符】 Interface 接口名 ｛

​		功能，用方法标识，接口中的方法默认使用 public abstract 修饰

​	｝

2、如何使用接口

​	class  类  implements 接口 {

​		从写接口中的抽象方法

​	}

3、接口中的方法默认使用 public abstract 修饰

4、就扣不能实例化对象

5、接口引用需要赋值视线里对象

6、通过接口引用，调用接口的抽象方法，实际上是执行的实现类对象的方法，这是接口的多态

7、接口的引用，可以赋值匿名对象

PS：

1、接口中方法默认使用 public abstract 修饰，接口中还可以定义public static final 常量，public static 方法， public default 方法

2、类实现了接口，需要重写接口的抽象方法，如果没有重写接口中所有的抽象方法，实现类需要定义为抽象类

3、接口是一种引用数据类型，可以定义变量，但接口不能实例化对象，接口的引用需要赋实现类对象，或者接口的匿名内部类对象

4、接口多态，接口应用调用接口中的抽象方法，实际上执行的是实现类对象的方法，接口存在就是为了实现多态

5、一个类可以同时实现多个接口，需要重写所有接口的抽象方法

6、接口也支持集成，并且接口支持多继承

# 接口与抽象类的异同点

相同点：

​	1）都可以定义抽象方法

​	2）都不能实例化对象

​	3）定义的抽象方法都需要被重写

​	4）都可以定义 public static 方法，public static final 常量

不同点：

​	1）意义不同

​			抽象类是对事物更高层级的抽象

​			接口是对功能的封装

​	2）定义方式不同

​		抽象类用 abstract class 定义

​		接口用 interface 定义

​	3）内容不同

​		抽象类中除了抽象放放外，还可以定义构造方法等比普通类中定义的所有成员

​		接口除了抽象类方法这四个内同外，不能定义构造防范等内容
​	4）使用方式不同

​		抽象类需要被子类继承 extends

​		接口需要别实现类实现 implements

​	5）类只支持单继承，接口支持多继承

​	6）应用场景不同

​		一般情况向，对类进行功能的廓镇，优先选择接口

​		除了扩展功能外，还需要保存不同的数据，只能选择抽象类；抽象类的抽象方法需要子类重写，抽象类还可以约束所有的子类都具有相同的功能



# 接口的应用

1、接口用来封装功能（操作）

2、接口可以定义一族操作规范



# 类与类之间的关系

1、泛化（继承）

​	一个类继承另外一个类，一个接口继承另外一个接口

2、实现

​	一个类实现接口

3、依赖

​	一个A类的方法返回值类型，方法参数类型或者是局部变量类型使用另外一个B类，成为A类依赖B类

4、关联

​	如果A类使用B类定义了成员变量，就称A类关联了B类

5、聚合、

​	聚合是关联的一种，如果一个类A是有若干的B类组成的并且不能决定B类的生命周期，则成A类为聚合类

6、组合

​	组合是关联的一种，如果一个类A是由若干的B类组成的并且可以决定B的声明周期，则称A类为组合

7、其他关系

​	is a： A类 is a B 类 （子类 is a 父类），是集成关系，也只有两个类符合is a关系是才能使用集成

​	like a：类 like a 接口，是实现关系

​	has a： A类 has a B类，关联关系

# 异常

## Throws抛出处理

在定义方法是，如果方法体重有受检异常需要预处理，可以捕获处理，也可以抛出处理。

谁调用这个放放，谁负责处理该异常。

在定义方法时，把异常抛出就是为了提醒方法使用者，有异常需要预处理。



在处理异常时，是选择捕获处理还是抛出处理？

​	1、一般情况下，在调用其他方法是，如果被调用的方法有收件异常需要预处理，选择捕获处理

​	2、在定义方法时，如果方法体重有受检异常要处理，可以选择捕获，也可以选择抛出处理；如果方法体中中通过throw 语句抛出了一个异常对象，所在的方法应该使用throws声明该对象

## 方法覆盖中的异常处理



1、方法覆盖（重写）规则

​	1）方法签名必须相同，方法与参数列表就是方法签名

​	2）方法的返回类型可以想通，子类方法的返回值类型可以是父类方法返回类型的子类型

​	3）子类方法到的访问权限可以更宽泛（更大）

​		a）如果父类方法使用 public 修饰，子类方法只能用public修饰

​		b）如果父类方法使用protected修饰，自乐方法可以是protected/public修饰

​	4）子类方法的异常要比父类方法的异常更小

​		a）如果父类方法没有抛出异常，子类重写后也不能抛出异常

​		b）如果父类方法抛出了异常，子类方法可以抛出相同的异常，也可以抛出父类异常的子类异常，也可以不抛出异常

2、异常在开发中的应用

​	1）自定义异常

​		a）定义一个类集成Exception

​		b）在自定义异常中提供两个构造函数，无参构造和带String的有参构造

​		c）在需要的位置通过throw抛出异常对象

​		d）throw所在的方法通过throws声明该异常

​		e）调用方法时，需要对受检异常预处理